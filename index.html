<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>마인크래프트 MIDI 변환 스튜디오</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & Babel for JSX -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.28/build/Midi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <!-- Lucide icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
    </style>
</head>
<body class="bg-gray-800">
    <div id="root"></div>

    <script type="text/babel" data-presets="react">
        // --- Global variables from libraries ---
        const { useState, useEffect, useRef, useCallback } = React;
        
        // --- Minecraft 사운드 목록 ---
        const MINECRAFT_SOUNDS = [
          "note.banjo", "note.bass", "note.bassattack", "note.bd", "note.bit",
          "note.cow_bell", "note.didgeridoo", "note.flute", "note.guitar",
          "note.harp", "note.hat", "note.icechime", "note.iron_xylophone",
          "note.pling", "note.snare", "note.xylobone"
        ];

        // --- Base64 인코딩된 오디오 데이터 ---
        const SOUND_DATA_BASE64 = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
        const SOUND_DATA_MAP = MINECRAFT_SOUNDS.reduce((acc, sound) => {
            acc[sound] = SOUND_DATA_BASE64;
            return acc;
        }, {});

        // --- 피치 계산 함수 ---
        const calculatePitch = (midiNote) => {
          return Math.pow(2, (midiNote - 66) / 12);
        };

        // --- 아이콘 컴포넌트들 ---
        const Icon = ({ name, size = 24, className = "" }) => {
          const iconElement = React.createElement('i', {
            'data-lucide': name,
            className: className,
            style: { width: size, height: size }
          });
          
          useEffect(() => {
            if (window.lucide) {
              window.lucide.createIcons();
            }
          });
          
          return iconElement;
        };

        // --- 피아노 롤 컴포넌트 ---
        function PianoRoll({ midiData, playbackState }) {
          const containerRef = useRef(null);
          const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
          const notes = midiData?.tracks.flatMap((track, trackIndex) => track.notes.map(note => ({...note, trackIndex}))) || [];
          const minMidi = notes.length > 0 ? Math.min(...notes.map(n => n.midi)) : 21;
          const maxMidi = notes.length > 0 ? Math.max(...notes.map(n => n.midi)) : 108;
          const totalDuration = midiData?.duration || 1;
          const keyHeight = Math.max(1, dimensions.height / (maxMidi - minMidi + 1));
          const timeScale = dimensions.width / totalDuration;
          const [currentTime, setCurrentTime] = useState(0);

          useEffect(() => {
            const updateDimensions = () => {
              if (containerRef.current) {
                setDimensions({ width: containerRef.current.offsetWidth, height: containerRef.current.offsetHeight });
              }
            };
            updateDimensions();
            window.addEventListener('resize', updateDimensions);
            return () => window.removeEventListener('resize', updateDimensions);
          }, []);
          
          useEffect(() => {
            let animationFrameId;
            const animate = () => {
              if (Tone.Transport.state === 'started') {
                setCurrentTime(Tone.Transport.seconds);
                animationFrameId = requestAnimationFrame(animate);
              }
            };
            if (playbackState === 'playing') {
              animationFrameId = requestAnimationFrame(animate);
            } else {
              if(animationFrameId) cancelAnimationFrame(animationFrameId);
              if (playbackState === 'stopped') setCurrentTime(0);
            }
            return () => { if(animationFrameId) cancelAnimationFrame(animationFrameId) };
          }, [playbackState]);

          const trackColors = ['#3b82f6', '#ef4444', '#22c55e', '#eab308', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316', '#6366f1', '#d946ef'];

          return (
            <div ref={containerRef} className="w-full h-full bg-gray-800 rounded-lg overflow-auto relative">
              <svg width={dimensions.width} height={dimensions.height} className="absolute top-0 left-0">
                <defs>
                  <pattern id="grid" width={timeScale > 0 ? timeScale : 1} height={keyHeight * 12} patternUnits="userSpaceOnUse">
                     <path d={`M ${timeScale} 0 L 0 0 0 ${keyHeight * 12}`} fill="none" stroke="rgba(255,255,255,0.05)" strokeWidth="1"/>
                  </pattern>
                  <pattern id="piano-keys" width="100" height={keyHeight * 12} patternUnits="userSpaceOnUse">
                    {[...Array(12).keys()].map(i => {
                      const isBlackKey = [1, 3, 6, 8, 10].includes(i % 12);
                      return <rect key={i} y={i * keyHeight} width="100" height={keyHeight} fill={isBlackKey ? 'rgba(0,0,0,0.2)' : 'rgba(255,255,255,0.02)'} />
                    })}
                  </pattern>
                </defs>
                <rect width="100%" height="100%" fill="url(#piano-keys)" />
                <rect width="100%" height="100%" fill="url(#grid)" />
                {notes.map((note, i) => {
                  const y = (maxMidi - note.midi) * keyHeight;
                  const x = note.time * timeScale;
                  const width = note.duration * timeScale;
                  const color = trackColors[note.trackIndex % trackColors.length];
                  return (
                    <rect key={i} x={x} y={y} width={Math.max(1, width)} height={keyHeight} fill={color} rx="2" ry="2" className="opacity-80 hover:opacity-100 transition-opacity">
                      <title>{`트랙: ${midiData.tracks[note.trackIndex].instrument.name}, 노트: ${note.name}, 시간: ${note.time.toFixed(2)}s`}</title>
                    </rect>
                  );
                })}
                <line x1={currentTime * timeScale} y1="0" x2={currentTime * timeScale} y2={dimensions.height} stroke="#facc15" strokeWidth="2" style={{ display: playbackState === 'stopped' ? 'none' : 'block' }} />
              </svg>
            </div>
          );
        }

        // --- 메인 앱 컴포넌트 ---
        function App() {
          const [midiData, setMidiData] = useState(null);
          const [fileName, setFileName] = useState("");
          const [instrumentMapping, setInstrumentMapping] = useState({});
          const [players, setPlayers] = useState(null);
          const [areSoundsLoaded, setAreSoundsLoaded] = useState(false);
          const [playbackState, setPlaybackState] = useState('stopped');
          const [isLoading, setIsLoading] = useState(true);
          const [loadingError, setLoadingError] = useState(null);
          const [isExporting, setIsExporting] = useState(false);
          const [activeTab, setActiveTab] = useState('tracks');
          const [showInstructions, setShowInstructions] = useState(true);

          const scheduledEvents = useRef([]);

          useEffect(() => {
            const init = async () => {
              setIsLoading(true);
              try {
                // Tone.js를 사용하기 전에 사용자 상호작용이 필요할 수 있으므로, 시작 컨텍스트를 만들어줍니다.
                await Tone.start();
                const loadedPlayers = await new Promise((resolve) => {
                  const tonePlayers = new Tone.Players(SOUND_DATA_MAP, () => resolve(tonePlayers)).toDestination();
                });
                setPlayers(loadedPlayers);
                setAreSoundsLoaded(true);
              } catch (error) {
                console.error("사운드 초기화 실패:", error);
                setLoadingError("사운드 플레이어를 초기화할 수 없습니다. 브라우저가 Web Audio API를 지원하는지 확인해주세요.");
              } finally {
                setIsLoading(false);
              }
            };
            init();
          }, []);

          const handleFileChange = async (event) => {
            const file = event.target.files[0];
            if (file) {
              setIsLoading(true);
              setFileName(file.name.replace(/\.(mid|midi)$/, ''));
              const reader = new FileReader();
              reader.onload = async (e) => {
                try {
                  const midi = new Midi(e.target.result);
                  setMidiData(midi);
                  const initialMapping = {};
                  midi.tracks.forEach((track, index) => {
                    const trackName = track.instrument.name.toLowerCase();
                    const foundSound = MINECRAFT_SOUNDS.find(s => trackName.includes(s.split('.')[1])) || MINECRAFT_SOUNDS[index % MINECRAFT_SOUNDS.length];
                    initialMapping[index] = foundSound;
                  });
                  setInstrumentMapping(initialMapping);
                  setShowInstructions(false);
                } catch (error) {
                  console.error("MIDI 파일 파싱 오류:", error);
                  setLoadingError("유효하지 않은 MIDI 파일입니다.");
                }
                setIsLoading(false);
              };
              reader.readAsArrayBuffer(file);
            }
          };

          const handleInstrumentChange = (trackIndex, sound) => {
            setInstrumentMapping(prev => ({ ...prev, [trackIndex]: sound }));
          };

          const schedulePlayback = useCallback(() => {
            if (!midiData || !areSoundsLoaded || !players) return;
            scheduledEvents.current.forEach(id => Tone.Transport.clear(id));
            scheduledEvents.current = [];
            midiData.tracks.forEach((track, trackIndex) => {
              const instrument = instrumentMapping[trackIndex];
              if (instrument && players.has(instrument)) {
                track.notes.forEach(note => {
                  const eventId = Tone.Transport.scheduleOnce(time => {
                    const player = players.player(instrument);
                    if(player.loaded) {
                        player.playbackRate = calculatePitch(note.midi);
                        player.start(time, 0, note.duration);
                    }
                  }, note.time);
                  scheduledEvents.current.push(eventId);
                });
              }
            });
          }, [midiData, areSoundsLoaded, instrumentMapping, players]);

          const togglePlayback = async () => {
            if (!areSoundsLoaded) {
                alert("사운드가 로드되지 않았습니다.");
                return;
            }
            // 오디오 컨텍스트 시작
            await Tone.start();
            if (Tone.Transport.state === 'started') {
              Tone.Transport.pause();
              setPlaybackState('paused');
            } else {
              schedulePlayback();
              Tone.Transport.start();
              setPlaybackState('playing');
            }
          };

          const stopPlayback = () => {
            Tone.Transport.stop();
            if (players) players.stopAll();
            Tone.Transport.position = 0;
            setPlaybackState('stopped');
          };
          
          useEffect(() => {
            const onStop = () => setPlaybackState('stopped');
            Tone.Transport.on('stop', onStop);
            return () => Tone.Transport.off('stop', onStop);
          }, []);

          const exportMcFunction = async () => {
            if (!midiData) return;
            setIsExporting(true);
            const zip = new JSZip();
            const folderName = fileName.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'minecraft_music';
            const musicFolder = zip.folder(folderName);
            const ticks = {};
            let maxTick = 0;
            midiData.tracks.forEach((track, trackIndex) => {
              const sound = instrumentMapping[trackIndex];
              if (!sound) return;
              track.notes.forEach(note => {
                const tick = Math.round(note.time * 20);
                const pitch = calculatePitch(note.midi).toFixed(4);
                const command = `playsound ${sound} @a ~~~ 1.0 ${pitch}`;
                if (!ticks[tick]) ticks[tick] = [];
                ticks[tick].push(command);
                if (tick > maxTick) maxTick = tick;
              });
            });
            musicFolder.file('setup.mcfunction', 'scoreboard objectives add musicTimer dummy "Music Timer"');
            let playFunctionContent = `scoreboard players add @a[tag=${folderName}] musicTimer 1\n`;
            for (let i = 0; i <= maxTick; i++) {
                if(ticks[i]){
                    playFunctionContent += `execute as @a[scores={musicTimer=${i}}] at @s run function ${folderName}/tick_${i}\n`;
                }
            }
            playFunctionContent += `scoreboard players reset @a[tag=${folderName},scores={musicTimer=${maxTick+1}..}] musicTimer`;
            musicFolder.file('play.mcfunction', playFunctionContent);
            for (const tick in ticks) {
              musicFolder.file(`tick_${tick}.mcfunction`, ticks[tick].join('\n'));
            }
            const readmeContent = `마인크래프트 음악 팩 사용법 (${folderName})

1. 이 ZIP 파일을 압축 해제합니다.
2. 마인크래프트 베드락 에디션 월드의 behavior_packs 폴더에 압축 해제한 폴더를 복사합니다.
3. 월드에서 다음 명령어를 실행합니다:
   /function ${folderName}/setup
4. 음악을 재생하려는 플레이어에게 태그를 추가합니다:
   /tag @s add ${folderName}
5. 다음 명령어로 음악을 시작합니다:
   /function ${folderName}/play
6. 음악을 중지하려면:
   /tag @s remove ${folderName}

주의사항:
- 이 함수는 반복 실행되는 명령 블록이나 틱 함수에서 실행해야 합니다.
- 음악 재생 중에는 ${folderName} 태그가 있는 플레이어 주변에서 사운드가 재생됩니다.`;
            musicFolder.file('README.txt', readmeContent);
            const content = await zip.generateAsync({ type: 'blob' });
            saveAs(content, `${folderName}.zip`);
            setIsExporting(false);
          };

          return (
            <div className="bg-gray-800 text-white min-h-screen font-sans flex flex-col">
              <header className="bg-gray-900 p-4 shadow-lg flex justify-between items-center">
                <div className="flex items-center gap-3">
                  <Icon name="music" size={32} className="text-blue-400" />
                  <div>
                    <h1 className="text-xl font-bold">MCBE MIDI 변환 스튜디오</h1>
                    <p className="text-xs text-gray-400">MIDI를 마인크래프트 playsound 명령어로</p>
                  </div>
                </div>
                <div className="flex items-center gap-4">
                  <label htmlFor="midi-upload" className="bg-blue-600 font-bold py-2 px-4 rounded-lg flex items-center gap-2 transition-colors hover:bg-blue-700 cursor-pointer">
                    <Icon name="upload" size={20} /> MIDI 업로드
                  </label>
                  <input type="file" id="midi-upload" accept=".mid,.midi" className="hidden" onChange={handleFileChange} />
                </div>
              </header>

              {isLoading && (
                <div className="absolute inset-0 bg-gray-900 bg-opacity-75 flex flex-col justify-center items-center z-50">
                  <Icon name="loader-2" size={64} className="animate-spin text-blue-400" />
                  <p className="mt-4 text-lg">초기화 중...</p>
                </div>
              )}
               {isExporting && (
                <div className="absolute inset-0 bg-gray-900 bg-opacity-75 flex flex-col justify-center items-center z-50">
                  <Icon name="loader-2" size={64} className="animate-spin text-blue-400" />
                  <p className="mt-4 text-lg">McFunction 파일들을 생성 중입니다...</p>
                </div>
              )}
              
              <main className="flex-grow p-4 md:p-6 lg:p-8 flex flex-col md:flex-row gap-6">
                {loadingError && !isLoading && (
                    <div className="w-full flex flex-col items-center justify-center text-center bg-red-900/50 p-8 rounded-lg">
                        <Icon name="alert-triangle" size={48} className="text-red-400" />
                        <h2 className="mt-4 text-2xl font-bold">오류 발생</h2>
                        <p className="mt-2 text-red-300">{loadingError}</p>
                        <p className="mt-2 text-sm text-gray-400">페이지를 새로고침하여 다시 시도해주세요.</p>
                    </div>
                )}

                {!loadingError && midiData ? (
                  <>
                    <div className="w-full md:w-1/3 lg:w-1/4 bg-gray-800/50 rounded-lg shadow-xl p-4 flex flex-col">
                      <h2 className="text-lg font-semibold border-b border-gray-600 pb-2 mb-4">{fileName || "MIDI 정보"}</h2>
                      <div className="bg-gray-700 p-3 rounded-lg flex justify-around items-center mb-4">
                          <button onClick={togglePlayback} disabled={!areSoundsLoaded} className="p-3 bg-blue-600 rounded-full text-white hover:bg-blue-500 disabled:bg-gray-500 disabled:cursor-not-allowed transition-all transform hover:scale-110" title={!areSoundsLoaded ? "사운드 로딩 실패" : "재생/일시정지"}>
                              <Icon name={playbackState === 'playing' ? 'pause' : 'play'} size={24} />
                          </button>
                          <button onClick={stopPlayback} disabled={!areSoundsLoaded} className="p-3 bg-red-600 rounded-full text-white hover:bg-red-500 disabled:bg-gray-500 disabled:cursor-not-allowed transition-all transform hover:scale-110" title={!areSoundsLoaded ? "사운드 로딩 실패" : "정지"}>
                              <Icon name="square" size={24} />
                          </button>
                      </div>
                      <div className="flex border-b border-gray-600 mb-2">
                          <button onClick={() => setActiveTab('tracks')} className={`py-2 px-4 flex items-center gap-2 ${activeTab === 'tracks' ? 'border-b-2 border-blue-400 text-blue-300' : 'text-gray-400'}`}>
                              <Icon name="list-music" size={18}/> 트랙 목록
                          </button>
                          <button onClick={() => setActiveTab('export')} className={`py-2 px-4 flex items-center gap-2 ${activeTab === 'export' ? 'border-b-2 border-blue-400 text-blue-300' : 'text-gray-400'}`}>
                              <Icon name="download" size={18}/> 내보내기
                          </button>
                      </div>
                      {activeTab === 'tracks' && (
                        <div className="flex-grow overflow-y-auto pr-2">
                          <p className="text-sm text-gray-400 mb-3">각 트랙에 마인크래프트 사운드를 지정하세요.</p>
                          {midiData.tracks.map((track, index) => (
                            <div key={index} className="mb-3 p-3 bg-gray-700 rounded-lg">
                              <p className="font-bold truncate" title={track.name || `트랙 ${index + 1}`}>{track.instrument.name || `트랙 ${index + 1}`}</p>
                              <p className="text-xs text-gray-400 mb-2">{track.notes.length}개의 노트</p>
                              <select value={instrumentMapping[index] || ''} onChange={(e) => handleInstrumentChange(index, e.target.value)} className="w-full p-2 bg-gray-600 border border-gray-500 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                                {MINECRAFT_SOUNDS.map(sound => (<option key={sound} value={sound}>{sound}</option>))}
                              </select>
                            </div>
                          ))}
                        </div>
                      )}
                      {activeTab === 'export' && (
                          <div className="flex-grow flex flex-col justify-center items-center">
                              <p className="text-center text-gray-300 mb-4">설정이 완료되었으면 .mcfunction 팩으로 내보내세요.</p>
                              <button onClick={exportMcFunction} className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2 transition-colors">
                                  <Icon name="download" size={20} /> ZIP으로 내보내기
                              </button>
                          </div>
                      )}
                    </div>
                    <div className="w-full md:w-2/3 lg:w-3/4 bg-gray-900/50 rounded-lg shadow-xl p-4 overflow-hidden">
                      <h3 className="text-lg font-semibold border-b border-gray-600 pb-2 mb-4">피아노 롤 (미리보기)</h3>
                      <PianoRoll midiData={midiData} playbackState={playbackState} />
                    </div>
                  </>
                ) : (
                  <div className="flex-grow flex justify-center items-center">
                    {!isLoading && !loadingError && showInstructions && (
                      <div className="text-center bg-gray-900/50 p-10 rounded-xl shadow-2xl max-w-2xl">
                        <Icon name="music" size={48} className="mx-auto text-blue-400 mb-4" />
                        <h2 className="text-3xl font-bold mb-2">마인크래프트 MIDI 변환 스튜디오에 오신 것을 환영합니다!</h2>
                        <p className="text-gray-300 mb-6">가지고 있는 MIDI 파일을 마인크래프트 베드락 에디션에서 재생할 수 있는 함수 팩으로 변환해보세요.</p>
                        <div className="text-left bg-gray-800 p-4 rounded-lg border border-gray-700">
                            <h3 className="font-semibold text-lg mb-2 flex items-center gap-2"><Icon name="info" size={20} /> 사용 방법</h3>
                            <ol className="list-decimal list-inside space-y-2 text-gray-400">
                                <li><span className="font-semibold text-white">MIDI 업로드:</span> 오른쪽 상단의 'MIDI 업로드' 버튼을 클릭하여 파일을 선택합니다.</li>
                                <li><span className="font-semibold text-white">악기 지정:</span> 왼쪽 패널에 표시된 각 트랙에 원하는 마인크래프트 소리를 할당합니다.</li>
                                <li><span className="font-semibold text-white">미리듣기:</span> 재생 버튼을 눌러 변환된 음악을 웹에서 직접 들어봅니다.</li>
                                <li><span className="font-semibold text-white">내보내기:</span> '내보내기' 탭에서 ZIP 파일로 다운로드하여 마인크래프트 월드에 적용합니다.</li>
                            </ol>
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </main>
            </div>
          );
        }

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
