import React, { useState, useEffect, useRef, useCallback } from 'react';
import * as Tone from 'tone';
import { Upload, Music, FileDown, Play, Pause, Square, Loader2, ListMusic, Settings, Info, AlertTriangle } from 'lucide-react';

// --- Minecraft 사운드 목록 ---
const MINECRAFT_SOUNDS = [
  "note.banjo", "note.bass", "note.bassattack", "note.bd", "note.bit",
  "note.cow_bell", "note.didgeridoo", "note.flute", "note.guitar",
  "note.harp", "note.hat", "note.icechime", "note.iron_xylophone",
  "note.pling", "note.snare", "note.xylobone"
];

// --- Base64 인코딩된 오디오 데이터 ---
// 네트워크 오류를 근본적으로 해결하기 위해, 외부 URL 대신 코드에 직접 오디오 데이터를 포함합니다.
// 아래 데이터는 모든 사운드를 위한 임시 플레이스홀더(짧은 클릭음)입니다.
// 실제 사운드로 교체하려면 각 .ogg 파일을 Base64로 인코딩하여 아래 맵에 추가해야 합니다.
const SOUND_DATA_BASE64 = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
const SOUND_DATA_MAP = MINECRAFT_SOUNDS.reduce((acc, sound) => {
    acc[sound] = SOUND_DATA_BASE64;
    return acc;
}, {});


// --- 피치 계산 함수 ---
const calculatePitch = (midiNote) => {
  return Math.pow(2, (midiNote - 66) / 12);
};

// --- 메인 앱 컴포넌트 ---
export default function App() {
  const [midiData, setMidiData] = useState(null);
  const [fileName, setFileName] = useState("");
  const [instrumentMapping, setInstrumentMapping] = useState({});
  const [players, setPlayers] = useState({});
  const [areSoundsLoaded, setAreSoundsLoaded] = useState(false);
  const [librariesLoaded, setLibrariesLoaded] = useState(false);
  const [playbackState, setPlaybackState] = useState('stopped');
  const [isLoading, setIsLoading] = useState(true);
  const [loadingError, setLoadingError] = useState(null);
  const [isExporting, setIsExporting] = useState(false);
  const [activeTab, setActiveTab] = useState('tracks');
  const [showInstructions, setShowInstructions] = useState(true);

  const scheduledEvents = useRef([]);

  // --- 외부 라이브러리 및 사운드 로딩 Effect ---
  useEffect(() => {
    const loadDependencies = async () => {
      setIsLoading(true);
      setLoadingError(null);
      try {
        // 1. 외부 라이브러리 동적 로드
        const loadScript = (src) => new Promise((resolve, reject) => {
          if (document.querySelector(`script[src="${src}"]`)) {
            resolve();
            return;
          }
          const script = document.createElement('script');
          script.src = src;
          script.async = true;
          script.onload = resolve;
          script.onerror = () => reject(new Error(`${src} 로딩 실패`));
          document.head.appendChild(script);
        });

        await Promise.all([
          loadScript('https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.28/build/Midi.min.js'),
          loadScript('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'),
          loadScript('https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js')
        ]);
        setLibrariesLoaded(true);

        // 2. Base64 데이터로부터 사운드 로드
        const loadedPlayers = await new Promise((resolve, reject) => {
            const tonePlayers = new Tone.Players(SOUND_DATA_MAP, () => {
                resolve(tonePlayers);
            }).toDestination();
        });
        
        setPlayers(loadedPlayers);
        setAreSoundsLoaded(true);

      } catch (error) {
        console.error("초기화 실패:", error);
        setLoadingError(error.message || "필수 라이브러리 또는 사운드 파일을 불러오는 데 실패했습니다.");
      } finally {
        setIsLoading(false);
      }
    };
    
    loadDependencies();
  }, []);

  // --- MIDI 파일 처리 ---
  const handleFileChange = async (event) => {
    if (!librariesLoaded) return;
    const file = event.target.files[0];
    if (file) {
      setIsLoading(true);
      setFileName(file.name.replace(/\.(mid|midi)$/, ''));
      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const midi = new window.Midi(e.target.result);
          setMidiData(midi);
          const initialMapping = {};
          midi.tracks.forEach((track, index) => {
            const trackName = track.instrument.name.toLowerCase();
            const foundSound = MINECRAFT_SOUNDS.find(s => trackName.includes(s.split('.')[1])) || MINECRAFT_SOUNDS[index % MINECRAFT_SOUNDS.length];
            initialMapping[index] = foundSound;
          });
          setInstrumentMapping(initialMapping);
          setShowInstructions(false);
        } catch (error) {
          console.error("MIDI 파일 파싱 오류:", error);
          setLoadingError("유효하지 않은 MIDI 파일입니다.");
        }
        setIsLoading(false);
      };
      reader.readAsArrayBuffer(file);
    }
  };

  // --- 악기 매핑 변경 ---
  const handleInstrumentChange = (trackIndex, sound) => {
    setInstrumentMapping(prev => ({ ...prev, [trackIndex]: sound }));
  };

  // --- 재생/일시정지/정지 로직 ---
  const schedulePlayback = useCallback(() => {
    if (!midiData || !areSoundsLoaded) return;
    scheduledEvents.current.forEach(id => Tone.Transport.clear(id));
    scheduledEvents.current = [];
    midiData.tracks.forEach((track, trackIndex) => {
      const instrument = instrumentMapping[trackIndex];
      if (instrument && players.has(instrument)) {
        track.notes.forEach(note => {
          const eventId = Tone.Transport.scheduleOnce(time => {
            const player = players.player(instrument);
            if(player.loaded) {
                player.playbackRate = calculatePitch(note.midi);
                player.start(time, 0, note.duration);
            }
          }, note.time);
          scheduledEvents.current.push(eventId);
        });
      }
    });
  }, [midiData, areSoundsLoaded, instrumentMapping, players]);

  const togglePlayback = () => {
    if (!areSoundsLoaded) {
        alert("사운드 파일이 로드되지 않아 미리듣기를 할 수 없습니다.");
        return;
    }
    if (playbackState === 'playing') {
      Tone.Transport.pause();
      setPlaybackState('paused');
    } else {
      schedulePlayback();
      Tone.Transport.start();
      setPlaybackState('playing');
    }
  };

  const stopPlayback = () => {
    Tone.Transport.stop();
    if (players && typeof players.stopAll === 'function') {
        players.stopAll();
    }
    Tone.Transport.position = 0;
    setPlaybackState('stopped');
  };
  
  useEffect(() => {
    const onStop = () => setPlaybackState('stopped');
    Tone.Transport.on('stop', onStop);
    return () => Tone.Transport.off('stop', onStop);
  }, []);

  // --- .mcfunction 파일 생성 및 내보내기 ---
  const exportMcFunction = async () => {
    if (!midiData || !librariesLoaded) return;
    setIsExporting(true);
    const zip = new window.JSZip();
    const folderName = fileName.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'minecraft_music';
    const musicFolder = zip.folder(folderName);
    const ticks = {};
    let maxTick = 0;
    midiData.tracks.forEach((track, trackIndex) => {
      const sound = instrumentMapping[trackIndex];
      if (!sound) return;
      track.notes.forEach(note => {
        const tick = Math.round(note.time * 20);
        const pitch = calculatePitch(note.midi).toFixed(4);
        const command = `playsound ${sound} @a ~~~ 1.0 ${pitch}`;
        if (!ticks[tick]) ticks[tick] = [];
        ticks[tick].push(command);
        if (tick > maxTick) maxTick = tick;
      });
    });
    musicFolder.file('setup.mcfunction', 'scoreboard objectives add musicTimer dummy "Music Timer"');
    let playFunctionContent = `scoreboard players add @a[tag=${folderName}] musicTimer 1\n`;
    for (let i = 0; i <= maxTick; i++) {
        if(ticks[i]){
            playFunctionContent += `execute as @a[scores={musicTimer=${i}}] at @s run function ${folderName}/tick_${i}\n`;
        }
    }
    playFunctionContent += `scoreboard players reset @a[tag=${folderName},scores={musicTimer=${maxTick+1}..}] musicTimer`;
    musicFolder.file('play.mcfunction', playFunctionContent);
    for (const tick in ticks) {
      musicFolder.file(`tick_${tick}.mcfunction`, ticks[tick].join('\n'));
    }
    const readmeContent = `마인크래프트 음악 팩 사용법 (${folderName})\n\n이 팩은 마인크래프트 베드락 에디션에서 생성된 음악을 재생하기 위한 함수 팩입니다.\n\n**설치 방법:**\n\n1. 이 ZIP 파일의 압축을 해제합니다. '${folderName}' 폴더가 생성됩니다.\n2. 마인크래프트 월드의 'behavior_packs' 폴더에 '${folderName}' 폴더를 복사하여 붙여넣습니다.\n   - Windows 10/11: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang\\behavior_packs\n3. 마인크래프트 월드 설정 > 동작 팩 > 사용 가능에서 '${folderName}' 팩을 활성화합니다.\n\n**사용 방법:**\n\n1. 게임에 접속하여 채팅창에 다음 명령어를 입력하여 초기 설정을 합니다. (최초 1회)\n   /function ${folderName}/setup\n\n2. 음악을 재생할 플레이어에게 태그를 부여합니다.\n   /tag @s add ${folderName}\n\n3. 다음 명령어를 반복 커맨드 블록에 넣고 '항상 활성'으로 설정합니다.\n   /function ${folderName}/play\n\n4. 음악을 멈추고 싶으면 플레이어에게서 태그를 제거하거나 반복 커맨드 블록을 비활성화하세요.\n   /tag @s remove ${folderName}\n   /scoreboard players reset @s musicTimer`;
    musicFolder.file('README.txt', readmeContent);
    const content = await zip.generateAsync({ type: 'blob' });
    window.saveAs(content, `${folderName}.zip`);
    setIsExporting(false);
  };

  return (
    <div className="bg-gray-800 text-white min-h-screen font-sans flex flex-col">
      <header className="bg-gray-900 p-4 shadow-lg flex justify-between items-center">
        <div className="flex items-center gap-3">
          <Music className="text-blue-400" size={32} />
          <div>
            <h1 className="text-xl font-bold">MCBE MIDI 변환 스튜디오</h1>
            <p className="text-xs text-gray-400">MIDI를 마인크래프트 playsound 명령어로</p>
          </div>
        </div>
        <div className="flex items-center gap-4">
          <label htmlFor="midi-upload" className={`bg-blue-600 font-bold py-2 px-4 rounded-lg flex items-center gap-2 transition-colors ${!librariesLoaded ? 'cursor-not-allowed bg-gray-500' : 'hover:bg-blue-700 cursor-pointer'}`}>
            <Upload size={20} /> MIDI 업로드
          </label>
          <input type="file" id="midi-upload" accept=".mid,.midi" className="hidden" onChange={handleFileChange} disabled={!librariesLoaded} />
        </div>
      </header>

      {isLoading && (
        <div className="absolute inset-0 bg-gray-900 bg-opacity-75 flex flex-col justify-center items-center z-50">
          <Loader2 className="animate-spin text-blue-400" size={64} />
          <p className="mt-4 text-lg">초기화 중...</p>
        </div>
      )}
       {isExporting && (
        <div className="absolute inset-0 bg-gray-900 bg-opacity-75 flex flex-col justify-center items-center z-50">
          <Loader2 className="animate-spin text-blue-400" size={64} />
          <p className="mt-4 text-lg">McFunction 파일들을 생성 중입니다...</p>
        </div>
      )}
      
      <main className="flex-grow p-4 md:p-6 lg:p-8 flex flex-col md:flex-row gap-6">
        {loadingError && !isLoading && (
            <div className="w-full flex flex-col items-center justify-center text-center bg-red-900/50 p-8 rounded-lg">
                <AlertTriangle className="text-red-400" size={48} />
                <h2 className="mt-4 text-2xl font-bold">오류 발생</h2>
                <p className="mt-2 text-red-300">{loadingError}</p>
                <p className="mt-2 text-sm text-gray-400">네트워크 연결을 확인하거나 잠시 후 페이지를 새로고침 해주세요.</p>
            </div>
        )}

        {!loadingError && midiData ? (
          <>
            <div className="w-full md:w-1/3 lg:w-1/4 bg-gray-800/50 rounded-lg shadow-xl p-4 flex flex-col">
              <h2 className="text-lg font-semibold border-b border-gray-600 pb-2 mb-4">{fileName || "MIDI 정보"}</h2>
              <div className="bg-gray-700 p-3 rounded-lg flex justify-around items-center mb-4">
                  <button onClick={togglePlayback} disabled={!areSoundsLoaded} className="p-3 bg-blue-600 rounded-full text-white hover:bg-blue-500 disabled:bg-gray-500 disabled:cursor-not-allowed transition-all transform hover:scale-110" title={!areSoundsLoaded ? "사운드 로딩 실패" : "재생/일시정지"}>
                      {playbackState === 'playing' ? <Pause size={24} /> : <Play size={24} />}
                  </button>
                  <button onClick={stopPlayback} disabled={!areSoundsLoaded} className="p-3 bg-red-600 rounded-full text-white hover:bg-red-500 disabled:bg-gray-500 disabled:cursor-not-allowed transition-all transform hover:scale-110" title={!areSoundsLoaded ? "사운드 로딩 실패" : "정지"}>
                      <Square size={24} />
                  </button>
              </div>
              <div className="flex border-b border-gray-600 mb-2">
                  <button onClick={() => setActiveTab('tracks')} className={`py-2 px-4 flex items-center gap-2 ${activeTab === 'tracks' ? 'border-b-2 border-blue-400 text-blue-300' : 'text-gray-400'}`}>
                      <ListMusic size={18}/> 트랙 목록
                  </button>
                  <button onClick={() => setActiveTab('export')} className={`py-2 px-4 flex items-center gap-2 ${activeTab === 'export' ? 'border-b-2 border-blue-400 text-blue-300' : 'text-gray-400'}`}>
                      <FileDown size={18}/> 내보내기
                  </button>
              </div>
              {activeTab === 'tracks' && (
                <div className="flex-grow overflow-y-auto pr-2">
                  <p className="text-sm text-gray-400 mb-3">각 트랙에 마인크래프트 사운드를 지정하세요.</p>
                  {midiData.tracks.map((track, index) => (
                    <div key={index} className="mb-3 p-3 bg-gray-700 rounded-lg">
                      <p className="font-bold truncate" title={track.name || `트랙 ${index + 1}`}>{track.instrument.name || `트랙 ${index + 1}`}</p>
                      <p className="text-xs text-gray-400 mb-2">{track.notes.length}개의 노트</p>
                      <select value={instrumentMapping[index] || ''} onChange={(e) => handleInstrumentChange(index, e.target.value)} className="w-full p-2 bg-gray-600 border border-gray-500 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                        {MINECRAFT_SOUNDS.map(sound => (<option key={sound} value={sound}>{sound}</option>))}
                      </select>
                    </div>
                  ))}
                </div>
              )}
              {activeTab === 'export' && (
                  <div className="flex-grow flex flex-col justify-center items-center">
                      <p className="text-center text-gray-300 mb-4">설정이 완료되었으면 .mcfunction 팩으로 내보내세요.</p>
                      <button onClick={exportMcFunction} className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2 transition-colors">
                          <FileDown size={20} /> ZIP으로 내보내기
                      </button>
                  </div>
              )}
            </div>
            <div className="w-full md:w-2/3 lg:w-3/4 bg-gray-900/50 rounded-lg shadow-xl p-4 overflow-hidden">
              <h3 className="text-lg font-semibold border-b border-gray-600 pb-2 mb-4">피아노 롤 (미리보기)</h3>
              <PianoRoll midiData={midiData} playbackState={playbackState} />
            </div>
          </>
        ) : (
          <div className="flex-grow flex justify-center items-center">
            {!isLoading && !loadingError && showInstructions && (
              <div className="text-center bg-gray-900/50 p-10 rounded-xl shadow-2xl max-w-2xl">
                <Music size={48} className="mx-auto text-blue-400 mb-4" />
                <h2 className="text-3xl font-bold mb-2">마인크래프트 MIDI 변환 스튜디오에 오신 것을 환영합니다!</h2>
                <p className="text-gray-300 mb-6">가지고 있는 MIDI 파일을 마인크래프트 베드락 에디션에서 재생할 수 있는 함수 팩으로 변환해보세요.</p>
                <div className="text-left bg-gray-800 p-4 rounded-lg border border-gray-700">
                    <h3 className="font-semibold text-lg mb-2 flex items-center gap-2"><Info size={20} /> 사용 방법</h3>
                    <ol className="list-decimal list-inside space-y-2 text-gray-400">
                        <li><span className="font-semibold text-white">MIDI 업로드:</span> 오른쪽 상단의 'MIDI 업로드' 버튼을 클릭하여 파일을 선택합니다.</li>
                        <li><span className="font-semibold text-white">악기 지정:</span> 왼쪽 패널에 표시된 각 트랙에 원하는 마인크래프트 소리를 할당합니다.</li>
                        <li><span className="font-semibold text-white">미리듣기:</span> 재생 버튼을 눌러 변환된 음악을 웹에서 직접 들어봅니다.</li>
                        <li><span className="font-semibold text-white">내보내기:</span> '내보내기' 탭에서 ZIP 파일로 다운로드하여 마인크래프트 월드에 적용합니다.</li>
                    </ol>
                </div>
              </div>
            )}
          </div>
        )}
      </main>
    </div>
  );
}

// --- 피아노 롤 컴포넌트 ---
function PianoRoll({ midiData, playbackState }) {
  const containerRef = useRef(null);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  const notes = midiData?.tracks.flatMap((track, trackIndex) => track.notes.map(note => ({...note, trackIndex}))) || [];
  const minMidi = notes.length > 0 ? Math.min(...notes.map(n => n.midi)) : 21;
  const maxMidi = notes.length > 0 ? Math.max(...notes.map(n => n.midi)) : 108;
  const totalDuration = midiData?.duration || 1;
  const keyHeight = Math.max(1, dimensions.height / (maxMidi - minMidi + 1));
  const timeScale = dimensions.width / totalDuration;
  const [currentTime, setCurrentTime] = useState(0);

  useEffect(() => {
    const updateDimensions = () => {
      if (containerRef.current) {
        setDimensions({ width: containerRef.current.offsetWidth, height: containerRef.current.offsetHeight });
      }
    };
    updateDimensions();
    window.addEventListener('resize', updateDimensions);
    return () => window.removeEventListener('resize', updateDimensions);
  }, []);
  
  useEffect(() => {
    let animationFrameId;
    const animate = () => {
      if (playbackState === 'playing') {
        setCurrentTime(Tone.Transport.seconds);
        animationFrameId = requestAnimationFrame(animate);
      }
    };
    if (playbackState === 'playing') {
      animationFrameId = requestAnimationFrame(animate);
    } else {
      if(animationFrameId) cancelAnimationFrame(animationFrameId);
      if (playbackState === 'stopped') setCurrentTime(0);
    }
    return () => { if(animationFrameId) cancelAnimationFrame(animationFrameId) };
  }, [playbackState]);

  const trackColors = ['#3b82f6', '#ef4444', '#22c55e', '#eab308', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316', '#6366f1', '#d946ef'];

  return (
    <div ref={containerRef} className="w-full h-full bg-gray-800 rounded-lg overflow-auto relative">
      <svg width={dimensions.width} height={dimensions.height} className="absolute top-0 left-0">
        <defs>
          <pattern id="grid" width={timeScale > 0 ? timeScale : 1} height={keyHeight * 12} patternUnits="userSpaceOnUse">
             <path d={`M ${timeScale} 0 L 0 0 0 ${keyHeight * 12}`} fill="none" stroke="rgba(255,255,255,0.05)" strokeWidth="1"/>
          </pattern>
          <pattern id="piano-keys" width="100" height={keyHeight * 12} patternUnits="userSpaceOnUse">
            {[...Array(12).keys()].map(i => {
              const isBlackKey = [1, 3, 6, 8, 10].includes(i % 12);
              return <rect key={i} y={i * keyHeight} width="100" height={keyHeight} fill={isBlackKey ? 'rgba(0,0,0,0.2)' : 'rgba(255,255,255,0.02)'} />
            })}
          </pattern>
        </defs>
        <rect width="100%" height="100%" fill="url(#piano-keys)" />
        <rect width="100%" height="100%" fill="url(#grid)" />
        {notes.map((note, i) => {
          const y = (maxMidi - note.midi) * keyHeight;
          const x = note.time * timeScale;
          const width = note.duration * timeScale;
          const color = trackColors[note.trackIndex % trackColors.length];
          return (
            <rect key={i} x={x} y={y} width={Math.max(1, width)} height={keyHeight} fill={color} rx="2" ry="2" className="opacity-80 hover:opacity-100 transition-opacity">
              <title>{`트랙: ${midiData.tracks[note.trackIndex].instrument.name}, 노트: ${note.name}, 시간: ${note.time.toFixed(2)}s`}</title>
            </rect>
          );
        })}
        <line x1={currentTime * timeScale} y1="0" x2={currentTime * timeScale} y2={dimensions.height} stroke="#facc15" strokeWidth="2" style={{ display: playbackState === 'stopped' ? 'none' : 'block' }} />
      </svg>
    </div>
  );
}
